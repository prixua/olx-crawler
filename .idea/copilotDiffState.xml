<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/build.gradle">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/build.gradle" />
              <option name="originalContent" value="plugins {&#10;    id 'java'&#10;    id 'application'&#10;}&#10;&#10;group = 'br.olx.crawler'&#10;version = '1.0-SNAPSHOT'&#10;&#10;// Configurar encoding UTF-8 para compilação e execução&#10;java {&#10;    toolchain {&#10;        languageVersion = JavaLanguageVersion.of(11)&#10;    }&#10;}&#10;&#10;// Definir a classe principal para execução&#10;application {&#10;    mainClass = 'br.olx.crawler.OlxCrawler'&#10;}&#10;&#10;compileJava {&#10;    options.encoding = 'UTF-8'&#10;}&#10;&#10;compileTestJava {&#10;    options.encoding = 'UTF-8'&#10;}&#10;&#10;javadoc {&#10;    options.encoding = 'UTF-8'&#10;}&#10;&#10;repositories {&#10;    mavenCentral()&#10;}&#10;&#10;dependencies {&#10;    implementation 'com.fasterxml.jackson.dataformat:jackson-dataformat-xml:2.15.2'&#10;    implementation 'com.fasterxml.jackson.datatype:jackson-datatype-jsr310:2.15.2'&#10;    implementation 'com.google.guava:guava:32.1.2-jre'&#10;    implementation 'org.apache.commons:commons-lang3:3.13.0'&#10;    implementation 'org.slf4j:slf4j-api:2.0.9'&#10;    implementation 'ch.qos.logback:logback-classic:1.4.11'&#10;&#10;    // Lombok&#10;    compileOnly 'org.projectlombok:lombok:1.18.30'&#10;    annotationProcessor 'org.projectlombok:lombok:1.18.30'&#10;&#10;    testImplementation platform('org.junit:junit-bom:5.10.0')&#10;    testImplementation 'org.junit.jupiter:junit-jupiter'&#10;}&#10;&#10;test {&#10;    useJUnitPlatform()&#10;}&#10;&#10;// Configurar JVM para executar com UTF-8&#10;run {&#10;    systemProperty 'file.encoding', 'UTF-8'&#10;    systemProperty 'console.encoding', 'UTF-8'&#10;    jvmArgs '-Dfile.encoding=UTF-8'&#10;}&#10;" />
              <option name="updatedContent" value="plugins {&#10;    id 'java'&#10;    id 'application'&#10;}&#10;&#10;group = 'br.olx.crawler'&#10;version = '1.0-SNAPSHOT'&#10;&#10;// Definir a classe principal para execução&#10;application {&#10;    mainClass = 'br.olx.crawler.OlxCrawler'&#10;}&#10;&#10;compileJava {&#10;    options.encoding = 'UTF-8'&#10;}&#10;&#10;compileTestJava {&#10;    options.encoding = 'UTF-8'&#10;}&#10;&#10;javadoc {&#10;    options.encoding = 'UTF-8'&#10;}&#10;&#10;repositories {&#10;    mavenCentral()&#10;}&#10;&#10;dependencies {&#10;    implementation 'com.fasterxml.jackson.dataformat:jackson-dataformat-xml:2.15.2'&#10;    implementation 'com.fasterxml.jackson.datatype:jackson-datatype-jsr310:2.15.2'&#10;    implementation 'com.google.guava:guava:32.1.2-jre'&#10;    implementation 'org.apache.commons:commons-lang3:3.13.0'&#10;    implementation 'org.slf4j:slf4j-api:2.0.9'&#10;    implementation 'ch.qos.logback:logback-classic:1.4.11'&#10;&#10;    // Lombok&#10;    compileOnly 'org.projectlombok:lombok:1.18.30'&#10;    annotationProcessor 'org.projectlombok:lombok:1.18.30'&#10;&#10;    testImplementation platform('org.junit:junit-bom:5.10.0')&#10;    testImplementation 'org.junit.jupiter:junit-jupiter'&#10;}&#10;&#10;test {&#10;    useJUnitPlatform()&#10;}&#10;&#10;// Configurar JVM para executar com UTF-8&#10;run {&#10;    systemProperty 'file.encoding', 'UTF-8'&#10;    systemProperty 'console.encoding', 'UTF-8'&#10;    jvmArgs '-Dfile.encoding=UTF-8'&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/br.olx.crawler/OlxCrawler.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/br.olx.crawler/OlxCrawler.java" />
              <option name="originalContent" value="package br.olx.crawler;&#10;&#10;import br.olx.crawler.dto.Produto;&#10;import com.fasterxml.jackson.databind.JsonNode;&#10;import com.fasterxml.jackson.databind.ObjectMapper;&#10;&#10;import java.io.IOException;&#10;import java.io.PrintStream;&#10;import java.net.URI;&#10;import java.net.http.HttpClient;&#10;import java.net.http.HttpRequest;&#10;import java.net.http.HttpResponse;&#10;import java.nio.charset.StandardCharsets;&#10;import java.util.ArrayList;&#10;import java.util.Comparator;&#10;import java.util.LinkedHashMap;&#10;import java.util.List;&#10;import java.util.Locale;&#10;import java.util.Map;&#10;&#10;public class OlxCrawler {&#10;&#10;    private static final int MAX_PAGES = 10;&#10;    private static final int REQUESTS_INTERVAL_IN_MS = 1000;&#10;    &#10;    private static final String BASE_URL = &quot;https://www.olx.com.br/_next/data/GpvwIduHF4wjdvrZpgIXB/pt-BR/autos-e-pecas/motos/yamaha/mt-09/estado-rs.json&quot;&#10;            + &quot;?re=2019&amp;path=autos-e-pecas&amp;route=motos&amp;route=yamaha&amp;route=mt-09&amp;route=estado-rs&quot;;&#10;&#10;    public static void main(String[] args) {&#10;        // Configurar encoding UTF-8 para saída no console&#10;        configureConsoleEncoding();&#10;&#10;        try (HttpClient client = HttpClient.newHttpClient()) {&#10;            ObjectMapper mapper = new ObjectMapper();&#10;&#10;            int page = 1;&#10;            boolean hasMore = true;&#10;            Map&lt;String, Produto&gt; produtosUnicos = new LinkedHashMap&lt;&gt;(); // Mantém ordem e evita duplicatas&#10;&#10;            System.out.println(&quot;Iniciando busca... (máximo &quot; + OlxCrawler.MAX_PAGES + &quot; páginas)&quot;);&#10;&#10;            while (hasMore &amp;&amp; page &lt;= OlxCrawler.MAX_PAGES) {&#10;                String url = BASE_URL + &quot;&amp;page=&quot; + page;&#10;&#10;                HttpRequest request = HttpRequest.newBuilder()&#10;                        .uri(URI.create(url))&#10;                        .header(&quot;accept&quot;, &quot;application/json&quot;)&#10;                        .header(&quot;user-agent&quot;, &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64)&quot;)&#10;                        .header(&quot;x-nextjs-data&quot;, &quot;1&quot;)&#10;                        .build();&#10;&#10;                try {&#10;                    HttpResponse&lt;String&gt; response = client.send(request, HttpResponse.BodyHandlers.ofString());&#10;&#10;                    if (response.statusCode() == 200) {&#10;                        JsonNode root = mapper.readTree(response.body());&#10;                        JsonNode products = root.path(&quot;pageProps&quot;).path(&quot;ads&quot;);&#10;&#10;                        if (products.isArray() &amp;&amp; !products.isEmpty()) {&#10;                            System.out.println(&quot;Processando página &quot; + page + &quot;...&quot;);&#10;&#10;                            for (JsonNode product : products) {&#10;                                String titulo = product.path(&quot;title&quot;).asText();&#10;                                String preco = product.path(&quot;price&quot;).asText();&#10;                                String link = &quot;https://www.olx.com.br&quot; + product.path(&quot;url&quot;).asText();&#10;                                String imagem = product.path(&quot;images&quot;).isArray() &amp;&amp; !product.path(&quot;images&quot;).isEmpty()&#10;                                        ? product.path(&quot;images&quot;).get(0).path(&quot;original&quot;).asText()&#10;                                        : &quot;&quot;;&#10;&#10;                                if(titulo.toLowerCase(Locale.forLanguageTag(&quot;pt-BR&quot;)).contains(&quot;tracer&quot;)) {&#10;                                    // Usar o link como chave única para evitar duplicatas&#10;                                    if (!produtosUnicos.containsKey(link)) {&#10;                                        produtosUnicos.put(link, new Produto(titulo, preco, link, imagem));&#10;                                        System.out.println(&quot;  ✓ Produto único adicionado: &quot; + titulo);&#10;                                    } else {&#10;                                        System.out.println(&quot;  ⚠ Produto duplicado ignorado: &quot; + titulo);&#10;                                    }&#10;                                }&#10;                            }&#10;&#10;                            page++; // próxima página&#10;                            Thread.sleep(REQUESTS_INTERVAL_IN_MS); // espera 2 segundos antes de buscar a próxima&#10;                        } else {&#10;                            hasMore = false; // acabou os anúncios&#10;                        }&#10;&#10;                    } else {&#10;                        System.out.println(&quot;Erro HTTP &quot; + response.statusCode() + &quot; na página &quot; + page);&#10;                        hasMore = false;&#10;                    }&#10;&#10;                } catch (IOException | InterruptedException e) {&#10;                    System.err.println(&quot;Erro durante a requisição: &quot; + e.getMessage());&#10;                    hasMore = false;&#10;                }&#10;            }&#10;&#10;            // Converter Map para List para ordenação&#10;            List&lt;Produto&gt; todosProdutos = new ArrayList&lt;&gt;(produtosUnicos.values());&#10;&#10;            // Ordenar por preço (mais barato primeiro)&#10;            todosProdutos.sort(Comparator.comparingDouble(Produto::getPrecoNumerico));&#10;&#10;            // Mostrar resultados&#10;            System.out.println(&quot;\n&quot; + &quot;=&quot;.repeat(70));&#10;            System.out.println(&quot;RESULTADOS FINAIS - &quot; + todosProdutos.size() + &quot; produtos únicos encontrados&quot;);&#10;            System.out.println(&quot;(Duplicatas foram removidas baseando-se no link único)&quot;);&#10;            System.out.println(&quot;Mostrando os 10 mais baratos:&quot;);&#10;            System.out.println(&quot;=&quot;.repeat(70));&#10;&#10;            int contador = 0;&#10;            for (Produto produto : todosProdutos) {&#10;                if (contador &gt;= OlxCrawler.MAX_PAGES) break;&#10;&#10;                System.out.println((contador + 1) + &quot;º lugar:&quot;);&#10;                System.out.println(produto);&#10;                contador++;&#10;            }&#10;&#10;            if (todosProdutos.isEmpty()) {&#10;                System.out.println(&quot;Nenhum produto com 'tracer' foi encontrado.&quot;);&#10;            } else if (todosProdutos.size() &gt; OlxCrawler.MAX_PAGES) {&#10;                System.out.println(&quot;... e mais &quot; + (todosProdutos.size() - OlxCrawler.MAX_PAGES) + &quot; produtos únicos.&quot;);&#10;            }&#10;&#10;        } catch (Exception e) {&#10;            System.err.println(&quot;Erro geral na aplicação: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    private static void configureConsoleEncoding() {&#10;        try {&#10;            // Configura System.out para UTF-8&#10;            System.setOut(new PrintStream(System.out, true, StandardCharsets.UTF_8));&#10;            System.setErr(new PrintStream(System.err, true, StandardCharsets.UTF_8));&#10;&#10;            // Define propriedades do sistema para UTF-8&#10;            System.setProperty(&quot;file.encoding&quot;, &quot;UTF-8&quot;);&#10;            System.setProperty(&quot;console.encoding&quot;, &quot;UTF-8&quot;);&#10;&#10;        } catch (Exception e) {&#10;            System.err.println(&quot;Aviso: Não foi possível configurar encoding UTF-8: &quot; + e.getMessage());&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package br.olx.crawler;&#10;&#10;import br.olx.crawler.dto.Produto;&#10;import br.olx.crawler.util.SystemOutUtil;&#10;import com.fasterxml.jackson.databind.JsonNode;&#10;import com.fasterxml.jackson.databind.ObjectMapper;&#10;&#10;import java.io.IOException;&#10;import java.net.URI;&#10;import java.net.http.HttpClient;&#10;import java.net.http.HttpRequest;&#10;import java.net.http.HttpResponse;&#10;import java.util.ArrayList;&#10;import java.util.Comparator;&#10;import java.util.LinkedHashMap;&#10;import java.util.List;&#10;import java.util.Locale;&#10;import java.util.Map;&#10;&#10;public class OlxCrawler {&#10;&#10;    private static final int MAX_PAGES = 10;&#10;    private static final int REQUESTS_INTERVAL_IN_MS = 1000;&#10;    &#10;    private static final String BASE_URL = &quot;https://www.olx.com.br/_next/data/GpvwIduHF4wjdvrZpgIXB/pt-BR/autos-e-pecas/motos/yamaha/mt-09/estado-rs.json&quot;&#10;            + &quot;?re=2019&amp;path=autos-e-pecas&amp;route=motos&amp;route=yamaha&amp;route=mt-09&amp;route=estado-rs&quot;;&#10;&#10;    public static void main(String[] args) {&#10;        // Configurar encoding UTF-8 para saída no console&#10;        SystemOutUtil.configureConsoleEncoding();&#10;&#10;        try (HttpClient client = HttpClient.newHttpClient()) {&#10;            ObjectMapper mapper = new ObjectMapper();&#10;&#10;            int page = 1;&#10;            boolean hasMore = true;&#10;            Map&lt;String, Produto&gt; produtosUnicos = new LinkedHashMap&lt;&gt;(); // Mantém ordem e evita duplicatas&#10;&#10;            System.out.println(&quot;Iniciando busca... (máximo &quot; + OlxCrawler.MAX_PAGES + &quot; páginas)&quot;);&#10;&#10;            while (hasMore &amp;&amp; page &lt;= OlxCrawler.MAX_PAGES) {&#10;                String url = BASE_URL + &quot;&amp;page=&quot; + page;&#10;&#10;                HttpRequest request = HttpRequest.newBuilder()&#10;                        .uri(URI.create(url))&#10;                        .header(&quot;accept&quot;, &quot;application/json&quot;)&#10;                        .header(&quot;user-agent&quot;, &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64)&quot;)&#10;                        .header(&quot;x-nextjs-data&quot;, &quot;1&quot;)&#10;                        .build();&#10;&#10;                try {&#10;                    HttpResponse&lt;String&gt; response = client.send(request, HttpResponse.BodyHandlers.ofString());&#10;&#10;                    if (response.statusCode() == 200) {&#10;                        JsonNode root = mapper.readTree(response.body());&#10;                        JsonNode products = root.path(&quot;pageProps&quot;).path(&quot;ads&quot;);&#10;&#10;                        if (products.isArray() &amp;&amp; !products.isEmpty()) {&#10;                            System.out.println(&quot;Processando página &quot; + page + &quot;...&quot;);&#10;&#10;                            for (JsonNode product : products) {&#10;                                String titulo = product.path(&quot;title&quot;).asText();&#10;                                String preco = product.path(&quot;price&quot;).asText();&#10;                                String link = &quot;https://www.olx.com.br&quot; + product.path(&quot;url&quot;).asText();&#10;                                String imagem = product.path(&quot;images&quot;).isArray() &amp;&amp; !product.path(&quot;images&quot;).isEmpty()&#10;                                        ? product.path(&quot;images&quot;).get(0).path(&quot;original&quot;).asText()&#10;                                        : &quot;&quot;;&#10;&#10;                                if(titulo.toLowerCase(Locale.forLanguageTag(&quot;pt-BR&quot;)).contains(&quot;tracer&quot;)) {&#10;                                    // Usar o link como chave única para evitar duplicatas&#10;                                    if (!produtosUnicos.containsKey(link)) {&#10;                                        produtosUnicos.put(link, new Produto(titulo, preco, link, imagem));&#10;                                        System.out.println(&quot;  ✓ Produto único adicionado: &quot; + titulo);&#10;                                    } else {&#10;                                        System.out.println(&quot;  ⚠ Produto duplicado ignorado: &quot; + titulo);&#10;                                    }&#10;                                }&#10;                            }&#10;&#10;                            page++; // próxima página&#10;                            Thread.sleep(REQUESTS_INTERVAL_IN_MS); // espera 2 segundos antes de buscar a próxima&#10;                        } else {&#10;                            hasMore = false; // acabou os anúncios&#10;                        }&#10;&#10;                    } else {&#10;                        System.out.println(&quot;Erro HTTP &quot; + response.statusCode() + &quot; na página &quot; + page);&#10;                        hasMore = false;&#10;                    }&#10;&#10;                } catch (IOException | InterruptedException e) {&#10;                    System.err.println(&quot;Erro durante a requisição: &quot; + e.getMessage());&#10;                    hasMore = false;&#10;                }&#10;            }&#10;&#10;            // Converter Map para List para ordenação&#10;            List&lt;Produto&gt; todosProdutos = new ArrayList&lt;&gt;(produtosUnicos.values());&#10;&#10;            // Ordenar por preço (mais barato primeiro)&#10;            todosProdutos.sort(Comparator.comparingDouble(Produto::getPrecoNumerico));&#10;&#10;            // Mostrar resultados&#10;            System.out.println(&quot;\n&quot; + &quot;=&quot;.repeat(70));&#10;            System.out.println(&quot;RESULTADOS FINAIS - &quot; + todosProdutos.size() + &quot; produtos únicos encontrados&quot;);&#10;            System.out.println(&quot;(Duplicatas foram removidas baseando-se no link único)&quot;);&#10;            System.out.println(&quot;Mostrando os 10 mais baratos:&quot;);&#10;            System.out.println(&quot;=&quot;.repeat(70));&#10;&#10;            int contador = 0;&#10;            for (Produto produto : todosProdutos) {&#10;                if (contador &gt;= OlxCrawler.MAX_PAGES) break;&#10;&#10;                System.out.println((contador + 1) + &quot;º lugar:&quot;);&#10;                System.out.println(produto);&#10;                contador++;&#10;            }&#10;&#10;            if (todosProdutos.isEmpty()) {&#10;                System.out.println(&quot;Nenhum produto com 'tracer' foi encontrado.&quot;);&#10;            } else if (todosProdutos.size() &gt; OlxCrawler.MAX_PAGES) {&#10;                System.out.println(&quot;... e mais &quot; + (todosProdutos.size() - OlxCrawler.MAX_PAGES) + &quot; produtos únicos.&quot;);&#10;            }&#10;&#10;        } catch (Exception e) {&#10;            System.err.println(&quot;Erro geral na aplicação: &quot; + e.getMessage());&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/br.olx.crawler/Produto.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/br.olx.crawler/Produto.java" />
              <option name="updatedContent" value="package br.olx.crawler;&#10;&#10;import lombok.Data;&#10;import lombok.EqualsAndHashCode;&#10;&#10;@Data&#10;@EqualsAndHashCode&#10;public class Produto {&#10;    private final String titulo;&#10;    private final String precoTexto;&#10;    private final double precoNumerico;&#10;    private final String link;&#10;    private final String imagem;&#10;&#10;    public Produto(String titulo, String precoTexto, String link, String imagem) {&#10;        this.titulo = titulo;&#10;        this.precoTexto = precoTexto;&#10;        this.link = link;&#10;        this.imagem = imagem;&#10;        this.precoNumerico = extrairPreco(precoTexto);&#10;    }&#10;&#10;    private double extrairPreco(String precoTexto) {&#10;        if (precoTexto == null || precoTexto.isEmpty()) {&#10;            return Double.MAX_VALUE; // Preço inválido vai para o final&#10;        }&#10;        &#10;        // Remove &quot;R$&quot;, pontos e vírgulas para extrair o número&#10;        String numeroLimpo = precoTexto.replaceAll(&quot;[R$\\s.]&quot;, &quot;&quot;).replace(&quot;,&quot;, &quot;.&quot;);&#10;        &#10;        try {&#10;            return Double.parseDouble(numeroLimpo);&#10;        } catch (NumberFormatException e) {&#10;            return Double.MAX_VALUE; // Se não conseguir converter, vai para o final&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public String toString() {&#10;        return &quot;Título: &quot; + titulo + &quot;\n&quot; +&#10;               &quot;Preço: &quot; + precoTexto + &quot;\n&quot; +&#10;               &quot;Link: &quot; + link + &quot;\n&quot; +&#10;               &quot;Imagem: &quot; + imagem + &quot;\n&quot; +&#10;               &quot;------------------------------------------------&quot;;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/br/olx/crawler/OlxCrawler.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/br/olx/crawler/OlxCrawler.java" />
              <option name="originalContent" value="package br.olx.crawler;&#10;&#10;import br.olx.crawler.dto.Produto;&#10;import br.olx.crawler.util.SystemOutUtil;&#10;&#10;import java.io.IOException;&#10;import java.net.URI;&#10;import java.net.http.HttpClient;&#10;import java.net.http.HttpRequest;&#10;import java.net.http.HttpResponse;&#10;import java.util.ArrayList;&#10;import java.util.Comparator;&#10;import java.util.LinkedHashMap;&#10;import java.util.List;&#10;import java.util.Map;&#10;import java.util.regex.Matcher;&#10;import java.util.regex.Pattern;&#10;&#10;public class OlxCrawler {&#10;&#10;    private static final int MAX_PAGES = 20;&#10;    private static final int REQUESTS_INTERVAL_IN_MS = 2000; // Aumentar intervalo&#10;&#10;    private static final String BASE_URL = &quot;https://www.olx.com.br/autos-e-pecas/motos/yamaha/mt-09/estado-rs&quot;;&#10;&#10;    public static void main(String[] args) {&#10;&#10;        SystemOutUtil.configureConsoleEncoding();&#10;&#10;        try (HttpClient client = HttpClient.newBuilder()&#10;                .followRedirects(HttpClient.Redirect.NORMAL)&#10;                .build()) {&#10;&#10;            int page = 1;&#10;            boolean hasMore = true;&#10;            Map&lt;String, Produto&gt; produtosUnicos = new LinkedHashMap&lt;&gt;();&#10;&#10;            System.out.println(&quot;Iniciando busca... (máximo &quot; + MAX_PAGES + &quot; páginas)&quot;);&#10;&#10;            while (hasMore &amp;&amp; page &lt;= MAX_PAGES) {&#10;                String url = BASE_URL + &quot;?o=&quot; + page;&#10;&#10;                HttpRequest request = HttpRequest.newBuilder()&#10;                        .uri(URI.create(url))&#10;                        .header(&quot;Accept&quot;, &quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7&quot;)&#10;                        .header(&quot;Accept-Language&quot;, &quot;pt-BR,pt;q=0.9,en;q=0.8&quot;)&#10;                        .header(&quot;User-Agent&quot;, &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36&quot;)&#10;                        .header(&quot;Referer&quot;, &quot;https://www.olx.com.br/&quot;)&#10;                        .header(&quot;Cache-Control&quot;, &quot;max-age=0&quot;)&#10;                        .build();&#10;&#10;                try {&#10;                    System.out.println(&quot;Acessando: &quot; + url);&#10;                    HttpResponse&lt;String&gt; response = client.send(request, HttpResponse.BodyHandlers.ofString());&#10;&#10;                    System.out.println(&quot;Status: &quot; + response.statusCode());&#10;&#10;                    if (response.statusCode() == 200) {&#10;                        String html = response.body();&#10;&#10;                        // Debug: verificar se recebemos HTML válido&#10;                        if (html.length() &lt; 1000) {&#10;                            System.out.println(&quot;Resposta muito pequena, pode ser bloqueio. Conteúdo: &quot; + html.substring(0, Math.min(200, html.length())));&#10;                        }&#10;&#10;                        // Extrair produtos do HTML usando regex&#10;                        List&lt;Produto&gt; produtosPagina = extrairProdutosDoHtml(html);&#10;&#10;                        if (!produtosPagina.isEmpty()) {&#10;                            System.out.println(&quot;Processando página &quot; + page + &quot; - &quot; + produtosPagina.size() + &quot; produtos encontrados&quot;);&#10;&#10;                            for (Produto produto : produtosPagina) {&#10;                                if (!produtosUnicos.containsKey(produto.getLink())) {&#10;                                    produtosUnicos.put(produto.getLink(), produto);&#10;                                    System.out.println(&quot;  ✓ Produto único adicionado: &quot; + produto.getTitulo());&#10;                                } else {&#10;                                    System.out.println(&quot;  ⚠ Produto duplicado ignorado: &quot; + produto.getTitulo());&#10;                                }&#10;                            }&#10;&#10;                            page++;&#10;                            Thread.sleep(REQUESTS_INTERVAL_IN_MS);&#10;                        } else {&#10;                            System.out.println(&quot;Nenhum produto encontrado na página &quot; + page + &quot;. Finalizando...&quot;);&#10;                            hasMore = false;&#10;                        }&#10;&#10;                    } else if (response.statusCode() == 403) {&#10;                        System.out.println(&quot;Erro 403 - Acesso negado. Tentando aguardar mais tempo...&quot;);&#10;                        Thread.sleep(5000); // Esperar 5 segundos&#10;&#10;                        // Tentar uma vez mais com delay maior&#10;                        if (page == 1) {&#10;                            System.out.println(&quot;Tentativa 2 para página &quot; + page);&#10;                            Thread.sleep(3000);&#10;                            continue; // Tentar novamente sem incrementar página&#10;                        } else {&#10;                            hasMore = false;&#10;                        }&#10;                    } else {&#10;                        System.out.println(&quot;Erro HTTP &quot; + response.statusCode() + &quot; na página &quot; + page);&#10;                        if (response.body() != null &amp;&amp; !response.body().isEmpty()) {&#10;                            System.out.println(&quot;Resposta: &quot; + response.body().substring(0, Math.min(200, response.body().length())));&#10;                        }&#10;                        hasMore = false;&#10;                    }&#10;&#10;                } catch (IOException | InterruptedException e) {&#10;                    System.err.println(&quot;Erro durante a requisição: &quot; + e.getMessage());&#10;                    hasMore = false;&#10;                }&#10;            }&#10;&#10;            // Converter Map para List para ordenação&#10;            List&lt;Produto&gt; todosProdutos = new ArrayList&lt;&gt;(produtosUnicos.values());&#10;&#10;            // Ordenar por preço (mais barato primeiro)&#10;            todosProdutos.sort(Comparator.comparingDouble(Produto::getPrecoNumerico));&#10;&#10;            // Mostrar resultados&#10;            System.out.println(&quot;\n=== RESULTADOS FINAIS (Primeiros 10 mais baratos) ===&quot;);&#10;            System.out.println(&quot;Total de produtos únicos encontrados: &quot; + todosProdutos.size());&#10;&#10;            int count = 0;&#10;            for (Produto produto : todosProdutos) {&#10;                if (count &gt;= 10) break;&#10;&#10;                System.out.println(&quot;\n&quot; + (count + 1) + &quot;. &quot; + produto.getTitulo());&#10;                System.out.println(&quot;   Preço: &quot; + produto.getPreco());&#10;                System.out.println(&quot;   Link: &quot; + produto.getLink());&#10;                if (!produto.getImagem().isEmpty()) {&#10;                    System.out.println(&quot;   Imagem: &quot; + produto.getImagem());&#10;                }&#10;                count++;&#10;            }&#10;&#10;        } catch (Exception e) {&#10;            System.err.println(&quot;Erro geral: &quot; + e.getMessage());&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;&#10;    private static List&lt;Produto&gt; extrairProdutosDoHtml(String html) {&#10;        List&lt;Produto&gt; produtos = new ArrayList&lt;&gt;();&#10;&#10;        // Padrões regex mais específicos para capturar dados dos produtos&#10;        // Padrão para produtos com título e preço&#10;        Pattern produtoComPrecoPattern = Pattern.compile(&#10;            &quot;&lt;a[^&gt;]*href=\&quot;([^\&quot;]*)\&quot;[^&gt;]*&gt;.*?&quot; +&#10;            &quot;&lt;h2[^&gt;]*&gt;([^&lt;]+)&lt;/h2&gt;.*?&quot; +&#10;            &quot;(?:R\\$\\s*([\\d.,]+)|([\\d.,]+)\\s*mil)&quot;,&#10;            Pattern.DOTALL | Pattern.CASE_INSENSITIVE&#10;        );&#10;&#10;        // Padrão alternativo para produtos sem preço visível&#10;        Pattern produtoSemPrecoPattern = Pattern.compile(&#10;            &quot;&lt;a[^&gt;]*href=\&quot;([^\&quot;]*)\&quot;[^&gt;]*&gt;.*?&quot; +&#10;            &quot;&lt;h2[^&gt;]*&gt;([^&lt;]+)&lt;/h2&gt;&quot;,&#10;            Pattern.DOTALL | Pattern.CASE_INSENSITIVE&#10;        );&#10;&#10;        Pattern imagemPattern = Pattern.compile(&quot;&lt;img[^&gt;]*src=\&quot;([^\&quot;]*(?:jpg|jpeg|png|webp)[^\&quot;]*)&quot;, Pattern.CASE_INSENSITIVE);&#10;&#10;        // Primeiro tentar capturar produtos com preço&#10;        Matcher matcherComPreco = produtoComPrecoPattern.matcher(html);&#10;        while (matcherComPreco.find()) {&#10;            String link = matcherComPreco.group(1);&#10;            String titulo = matcherComPreco.group(2);&#10;            String precoReais = matcherComPreco.group(3);&#10;            String precoMil = matcherComPreco.group(4);&#10;&#10;            // Validar link (ignorar links inválidos como #header)&#10;            if (link == null || link.startsWith(&quot;#&quot;) || link.isEmpty()) {&#10;                continue;&#10;            }&#10;&#10;            // Limpar título&#10;            titulo = titulo.replaceAll(&quot;\\s+&quot;, &quot; &quot;).trim();&#10;&#10;            // Processar preço&#10;            String preco;&#10;            if (precoReais != null &amp;&amp; !precoReais.trim().isEmpty()) {&#10;                preco = &quot;R$ &quot; + precoReais.trim();&#10;            } else if (precoMil != null &amp;&amp; !precoMil.trim().isEmpty()) {&#10;                preco = precoMil.trim() + &quot; mil&quot;;&#10;            } else {&#10;                preco = &quot;Preço não informado&quot;;&#10;            }&#10;&#10;            // Garantir que o link seja absoluto&#10;            if (link.startsWith(&quot;/&quot;)) {&#10;                link = &quot;https://www.olx.com.br&quot; + link;&#10;            }&#10;&#10;            // Extrair imagem&#10;            String imagem = extrairImagemProxima(html, matcherComPreco.start());&#10;&#10;            produtos.add(new Produto(titulo, preco, link, imagem));&#10;        }&#10;&#10;        // Se não encontrou produtos com preço, tentar sem preço&#10;        if (produtos.isEmpty()) {&#10;            Matcher matcherSemPreco = produtoSemPrecoPattern.matcher(html);&#10;            while (matcherSemPreco.find()) {&#10;                String link = matcherSemPreco.group(1);&#10;                String titulo = matcherSemPreco.group(2);&#10;&#10;                // Validar link (ignorar links inválidos como #header)&#10;                if (link == null || link.startsWith(&quot;#&quot;) || link.isEmpty() ||&#10;                    titulo.toLowerCase().contains(&quot;acesse sua conta&quot;)) {&#10;                    continue;&#10;                }&#10;&#10;                // Limpar título&#10;                titulo = titulo.replaceAll(&quot;\\s+&quot;, &quot; &quot;).trim();&#10;&#10;                // Garantir que o link seja absoluto&#10;                if (link.startsWith(&quot;/&quot;)) {&#10;                    link = &quot;https://www.olx.com.br&quot; + link;&#10;                }&#10;&#10;                // Extrair imagem&#10;                String imagem = extrairImagemProxima(html, matcherSemPreco.start());&#10;&#10;                produtos.add(new Produto(titulo, &quot;Preço não informado&quot;, link, imagem));&#10;            }&#10;        }&#10;&#10;        return produtos;&#10;    }&#10;&#10;    private static String extrairImagemProxima(String html, int posicaoInicial) {&#10;        Pattern imagemPattern = Pattern.compile(&quot;&lt;img[^&gt;]*src=\&quot;([^\&quot;]*(?:jpg|jpeg|png|webp)[^\&quot;]*)&quot;, Pattern.CASE_INSENSITIVE);&#10;        Matcher imagemMatcher = imagemPattern.matcher(html);&#10;&#10;        while (imagemMatcher.find()) {&#10;            if (imagemMatcher.start() &gt; posicaoInicial) {&#10;                return imagemMatcher.group(1);&#10;            }&#10;        }&#10;        return &quot;&quot;;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package br.olx.crawler;&#10;&#10;import br.olx.crawler.dto.Produto;&#10;import br.olx.crawler.util.SystemOutUtil;&#10;&#10;import java.io.IOException;&#10;import java.net.URI;&#10;import java.net.http.HttpClient;&#10;import java.net.http.HttpRequest;&#10;import java.net.http.HttpResponse;&#10;import java.util.ArrayList;&#10;import java.util.Comparator;&#10;import java.util.LinkedHashMap;&#10;import java.util.List;&#10;import java.util.Map;&#10;import java.util.regex.Matcher;&#10;import java.util.regex.Pattern;&#10;&#10;public class OlxCrawler {&#10;&#10;    private static final int MAX_PAGES = 20;&#10;    private static final int REQUESTS_INTERVAL_IN_MS = 2000; // Aumentar intervalo&#10;&#10;    private static final String BASE_URL = &quot;https://www.olx.com.br/autos-e-pecas/motos/yamaha/mt-09/estado-rs&quot;;&#10;&#10;    public static void main(String[] args) {&#10;&#10;        SystemOutUtil.configureConsoleEncoding();&#10;&#10;        try (HttpClient client = HttpClient.newBuilder()&#10;                .followRedirects(HttpClient.Redirect.NORMAL)&#10;                .build()) {&#10;&#10;            int page = 1;&#10;            boolean hasMore = true;&#10;            Map&lt;String, Produto&gt; produtosUnicos = new LinkedHashMap&lt;&gt;();&#10;&#10;            System.out.println(&quot;Iniciando busca... (máximo &quot; + MAX_PAGES + &quot; páginas)&quot;);&#10;&#10;            while (hasMore &amp;&amp; page &lt;= MAX_PAGES) {&#10;                String url = BASE_URL + &quot;?o=&quot; + page;&#10;&#10;                HttpRequest request = HttpRequest.newBuilder()&#10;                        .uri(URI.create(url))&#10;                        .header(&quot;Accept&quot;, &quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7&quot;)&#10;                        .header(&quot;Accept-Language&quot;, &quot;pt-BR,pt;q=0.9,en;q=0.8&quot;)&#10;                        .header(&quot;User-Agent&quot;, &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36&quot;)&#10;                        .header(&quot;Referer&quot;, &quot;https://www.olx.com.br/&quot;)&#10;                        .header(&quot;Cache-Control&quot;, &quot;max-age=0&quot;)&#10;                        .build();&#10;&#10;                try {&#10;                    System.out.println(&quot;Acessando: &quot; + url);&#10;                    HttpResponse&lt;String&gt; response = client.send(request, HttpResponse.BodyHandlers.ofString());&#10;&#10;                    System.out.println(&quot;Status: &quot; + response.statusCode());&#10;&#10;                    if (response.statusCode() == 200) {&#10;                        String html = response.body();&#10;&#10;                        // Debug: verificar se recebemos HTML válido&#10;                        if (html.length() &lt; 1000) {&#10;                            System.out.println(&quot;Resposta muito pequena, pode ser bloqueio. Conteúdo: &quot; + html.substring(0, Math.min(200, html.length())));&#10;                        }&#10;&#10;                        // Extrair produtos do HTML usando regex&#10;                        List&lt;Produto&gt; produtosPagina = extrairProdutosDoHtml(html);&#10;&#10;                        if (!produtosPagina.isEmpty()) {&#10;                            System.out.println(&quot;Processando página &quot; + page + &quot; - &quot; + produtosPagina.size() + &quot; produtos encontrados&quot;);&#10;&#10;                            for (Produto produto : produtosPagina) {&#10;                                if (!produtosUnicos.containsKey(produto.getLink())) {&#10;                                    produtosUnicos.put(produto.getLink(), produto);&#10;                                    System.out.println(&quot;  ✓ Produto único adicionado: &quot; + produto.getTitulo());&#10;                                } else {&#10;                                    System.out.println(&quot;  ⚠ Produto duplicado ignorado: &quot; + produto.getTitulo());&#10;                                }&#10;                            }&#10;&#10;                            page++;&#10;                            Thread.sleep(REQUESTS_INTERVAL_IN_MS);&#10;                        } else {&#10;                            System.out.println(&quot;Nenhum produto encontrado na página &quot; + page + &quot;. Finalizando...&quot;);&#10;                            hasMore = false;&#10;                        }&#10;&#10;                    } else if (response.statusCode() == 403) {&#10;                        System.out.println(&quot;Erro 403 - Acesso negado. Tentando aguardar mais tempo...&quot;);&#10;                        Thread.sleep(5000); // Esperar 5 segundos&#10;&#10;                        // Tentar uma vez mais com delay maior&#10;                        if (page == 1) {&#10;                            System.out.println(&quot;Tentativa 2 para página &quot; + page);&#10;                            Thread.sleep(3000);&#10;                            continue; // Tentar novamente sem incrementar página&#10;                        } else {&#10;                            hasMore = false;&#10;                        }&#10;                    } else {&#10;                        System.out.println(&quot;Erro HTTP &quot; + response.statusCode() + &quot; na página &quot; + page);&#10;                        if (response.body() != null &amp;&amp; !response.body().isEmpty()) {&#10;                            System.out.println(&quot;Resposta: &quot; + response.body().substring(0, Math.min(200, response.body().length())));&#10;                        }&#10;                        hasMore = false;&#10;                    }&#10;&#10;                } catch (IOException | InterruptedException e) {&#10;                    System.err.println(&quot;Erro durante a requisição: &quot; + e.getMessage());&#10;                    hasMore = false;&#10;                }&#10;            }&#10;&#10;            // Converter Map para List para ordenação&#10;            List&lt;Produto&gt; todosProdutos = new ArrayList&lt;&gt;(produtosUnicos.values());&#10;&#10;            // Ordenar por preço (mais barato primeiro)&#10;            todosProdutos.sort(Comparator.comparingDouble(Produto::getPrecoNumerico));&#10;&#10;            // Mostrar resultados&#10;            System.out.println(&quot;\n=== RESULTADOS FINAIS (Primeiros 10 mais baratos) ===&quot;);&#10;            System.out.println(&quot;Total de produtos únicos encontrados: &quot; + todosProdutos.size());&#10;&#10;            int count = 0;&#10;            for (Produto produto : todosProdutos) {&#10;                if (count &gt;= 10) break;&#10;&#10;                System.out.println(&quot;\n&quot; + (count + 1) + &quot;. &quot; + produto.getTitulo());&#10;                System.out.println(&quot;   Preço: &quot; + produto.getPreco());&#10;                System.out.println(&quot;   Link: &quot; + produto.getLink());&#10;                if (!produto.getImagem().isEmpty()) {&#10;                    System.out.println(&quot;   Imagem: &quot; + produto.getImagem());&#10;                }&#10;                count++;&#10;            }&#10;&#10;        } catch (Exception e) {&#10;            System.err.println(&quot;Erro geral: &quot; + e.getMessage());&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;&#10;    private static List&lt;Produto&gt; extrairProdutosDoHtml(String html) {&#10;        List&lt;Produto&gt; produtos = new ArrayList&lt;&gt;();&#10;&#10;        // Padrões regex mais específicos para capturar dados dos produtos&#10;        // Padrão para produtos com título e preço&#10;        Pattern produtoComPrecoPattern = Pattern.compile(&#10;            &quot;&lt;a[^&gt;]*href=\&quot;([^\&quot;]*)\&quot;[^&gt;]*&gt;.*?&quot; +&#10;            &quot;&lt;h2[^&gt;]*&gt;([^&lt;]+)&lt;/h2&gt;.*?&quot; +&#10;            &quot;(?:R\\$\\s*([\\d.,]+)|([\\d.,]+)\\s*mil)&quot;,&#10;            Pattern.DOTALL | Pattern.CASE_INSENSITIVE&#10;        );&#10;&#10;        // Padrão alternativo para produtos sem preço visível&#10;        Pattern produtoSemPrecoPattern = Pattern.compile(&#10;            &quot;&lt;a[^&gt;]*href=\&quot;([^\&quot;]*)\&quot;[^&gt;]*&gt;.*?&quot; +&#10;            &quot;&lt;h2[^&gt;]*&gt;([^&lt;]+)&lt;/h2&gt;&quot;,&#10;            Pattern.DOTALL | Pattern.CASE_INSENSITIVE&#10;        );&#10;&#10;        Pattern imagemPattern = Pattern.compile(&quot;&lt;img[^&gt;]*src=\&quot;([^\&quot;]*(?:jpg|jpeg|png|webp)[^\&quot;]*)&quot;, Pattern.CASE_INSENSITIVE);&#10;&#10;        // Primeiro tentar capturar produtos com preço&#10;        Matcher matcherComPreco = produtoComPrecoPattern.matcher(html);&#10;        while (matcherComPreco.find()) {&#10;            String link = matcherComPreco.group(1);&#10;            String titulo = matcherComPreco.group(2);&#10;            String precoReais = matcherComPreco.group(3);&#10;            String precoMil = matcherComPreco.group(4);&#10;&#10;            // Validar link (ignorar links inválidos como #header)&#10;            if (link == null || link.startsWith(&quot;#&quot;) || link.isEmpty()) {&#10;                continue;&#10;            }&#10;&#10;            // Limpar título&#10;            titulo = titulo.replaceAll(&quot;\\s+&quot;, &quot; &quot;).trim();&#10;&#10;            // Filtrar apenas produtos que contenham &quot;tracer&quot;&#10;            if (!titulo.toLowerCase().contains(&quot;tracer&quot;)) {&#10;                continue;&#10;            }&#10;&#10;            // Processar preço&#10;            String preco;&#10;            if (precoReais != null &amp;&amp; !precoReais.trim().isEmpty()) {&#10;                preco = &quot;R$ &quot; + precoReais.trim();&#10;            } else if (precoMil != null &amp;&amp; !precoMil.trim().isEmpty()) {&#10;                preco = precoMil.trim() + &quot; mil&quot;;&#10;            } else {&#10;                preco = &quot;Preço não informado&quot;;&#10;            }&#10;&#10;            // Garantir que o link seja absoluto&#10;            if (link.startsWith(&quot;/&quot;)) {&#10;                link = &quot;https://www.olx.com.br&quot; + link;&#10;            }&#10;&#10;            // Extrair imagem&#10;            String imagem = extrairImagemProxima(html, matcherComPreco.start());&#10;&#10;            produtos.add(new Produto(titulo, preco, link, imagem));&#10;        }&#10;&#10;        // Se não encontrou produtos com preço, tentar sem preço&#10;        if (produtos.isEmpty()) {&#10;            Matcher matcherSemPreco = produtoSemPrecoPattern.matcher(html);&#10;            while (matcherSemPreco.find()) {&#10;                String link = matcherSemPreco.group(1);&#10;                String titulo = matcherSemPreco.group(2);&#10;&#10;                // Validar link (ignorar links inválidos como #header)&#10;                if (link == null || link.startsWith(&quot;#&quot;) || link.isEmpty() ||&#10;                    titulo.toLowerCase().contains(&quot;acesse sua conta&quot;)) {&#10;                    continue;&#10;                }&#10;&#10;                // Limpar título&#10;                titulo = titulo.replaceAll(&quot;\\s+&quot;, &quot; &quot;).trim();&#10;&#10;                // Filtrar apenas produtos que contenham &quot;tracer&quot;&#10;                if (!titulo.toLowerCase().contains(&quot;tracer&quot;)) {&#10;                    continue;&#10;                }&#10;&#10;                // Garantir que o link seja absoluto&#10;                if (link.startsWith(&quot;/&quot;)) {&#10;                    link = &quot;https://www.olx.com.br&quot; + link;&#10;                }&#10;&#10;                // Extrair imagem&#10;                String imagem = extrairImagemProxima(html, matcherSemPreco.start());&#10;&#10;                produtos.add(new Produto(titulo, &quot;Preço não informado&quot;, link, imagem));&#10;            }&#10;        }&#10;&#10;        return produtos;&#10;    }&#10;&#10;    private static String extrairImagemProxima(String html, int posicaoInicial) {&#10;        Pattern imagemPattern = Pattern.compile(&quot;&lt;img[^&gt;]*src=\&quot;([^\&quot;]*(?:jpg|jpeg|png|webp)[^\&quot;]*)&quot;, Pattern.CASE_INSENSITIVE);&#10;        Matcher imagemMatcher = imagemPattern.matcher(html);&#10;&#10;        while (imagemMatcher.find()) {&#10;            if (imagemMatcher.start() &gt; posicaoInicial) {&#10;                return imagemMatcher.group(1);&#10;            }&#10;        }&#10;        return &quot;&quot;;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/br/olx/crawler/dto/Produto.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/br/olx/crawler/dto/Produto.java" />
              <option name="originalContent" value="package br.olx.crawler.dto;&#10;&#10;import lombok.Getter;&#10;import lombok.EqualsAndHashCode;&#10;&#10;@Getter&#10;@EqualsAndHashCode(onlyExplicitlyIncluded = true)&#10;public class Produto {&#10;    private final String titulo;&#10;    private final String preco;&#10;    private final double precoNumerico;&#10;    @EqualsAndHashCode.Include&#10;    private final String link;&#10;    private final String imagem;&#10;&#10;    public Produto(String titulo, String preco, String link, String imagem) {&#10;        this.titulo = titulo;&#10;        this.preco = preco;&#10;        this.link = link;&#10;        this.imagem = imagem;&#10;        this.precoNumerico = extrairPreco(preco);&#10;    }&#10;&#10;    private double extrairPreco(String precoTexto) {&#10;        if (precoTexto == null || precoTexto.isEmpty() || precoTexto.equals(&quot;Preço não informado&quot;)) {&#10;            return Double.MAX_VALUE; // Preço inválido vai para o final&#10;        }&#10;&#10;        // Remove &quot;R$&quot;, pontos e vírgulas para extrair o número&#10;        String numeroLimpo = precoTexto.replaceAll(&quot;[R$\\s.]&quot;, &quot;&quot;).replace(&quot;,&quot;, &quot;.&quot;);&#10;&#10;        try {&#10;            return Double.parseDouble(numeroLimpo);&#10;        } catch (NumberFormatException e) {&#10;            return Double.MAX_VALUE; // Se não conseguir converter, vai para o final&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public String toString() {&#10;        return &quot;Título: &quot; + titulo + &quot;\n&quot; +&#10;               &quot;Preço: &quot; + preco + &quot;\n&quot; +&#10;               &quot;Link: &quot; + link + &quot;\n&quot; +&#10;               &quot;Imagem: &quot; + imagem + &quot;\n&quot; +&#10;               &quot;------------------------------------------------&quot;;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package br.olx.crawler.dto;&#10;&#10;public class Produto {&#10;    private final String titulo;&#10;    private final String preco;&#10;    private final double precoNumerico;&#10;    private final String link;&#10;    private final String imagem;&#10;&#10;    public Produto(String titulo, String preco, String link, String imagem) {&#10;        this.titulo = titulo;&#10;        this.preco = preco;&#10;        this.link = link;&#10;        this.imagem = imagem;&#10;        this.precoNumerico = extrairPreco(preco);&#10;    }&#10;&#10;    public String getTitulo() {&#10;        return titulo;&#10;    }&#10;&#10;    public String getPreco() {&#10;        return preco;&#10;    }&#10;&#10;    public double getPrecoNumerico() {&#10;        return precoNumerico;&#10;    }&#10;&#10;    public String getLink() {&#10;        return link;&#10;    }&#10;&#10;    public String getImagem() {&#10;        return imagem;&#10;    }&#10;&#10;    @Override&#10;    public boolean equals(Object o) {&#10;        if (this == o) return true;&#10;        if (o == null || getClass() != o.getClass()) return false;&#10;        Produto produto = (Produto) o;&#10;        return link.equals(produto.link);&#10;    }&#10;&#10;    @Override&#10;    public int hashCode() {&#10;        return link.hashCode();&#10;    }&#10;&#10;    private double extrairPreco(String precoTexto) {&#10;        if (precoTexto == null || precoTexto.isEmpty() || precoTexto.equals(&quot;Preço não informado&quot;)) {&#10;            return Double.MAX_VALUE; // Preço inválido vai para o final&#10;        }&#10;&#10;        // Remove &quot;R$&quot;, pontos e vírgulas para extrair o número&#10;        String numeroLimpo = precoTexto.replaceAll(&quot;[R$\\s.]&quot;, &quot;&quot;).replace(&quot;,&quot;, &quot;.&quot;);&#10;&#10;        try {&#10;            return Double.parseDouble(numeroLimpo);&#10;        } catch (NumberFormatException e) {&#10;            return Double.MAX_VALUE; // Se não conseguir converter, vai para o final&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public String toString() {&#10;        return &quot;Título: &quot; + titulo + &quot;\n&quot; +&#10;               &quot;Preço: &quot; + preco + &quot;\n&quot; +&#10;               &quot;Link: &quot; + link + &quot;\n&quot; +&#10;               &quot;Imagem: &quot; + imagem + &quot;\n&quot; +&#10;               &quot;------------------------------------------------&quot;;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/br/olx/crawler/util/SystemOutUtil.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/br/olx/crawler/util/SystemOutUtil.java" />
              <option name="originalContent" value="package br.olx.crawler.util;&#10;&#10;import java.io.PrintStream;&#10;import java.io.UnsupportedEncodingException;&#10;&#10;public class SystemOutUtil {&#10;    &#10;    public static void configureConsoleEncoding() {&#10;        try {&#10;            System.setOut(new PrintStream(System.out, true, &quot;UTF-8&quot;));&#10;        } catch (UnsupportedEncodingException e) {&#10;            System.err.println(&quot;Erro ao configurar codificação UTF-8: &quot; + e.getMessage());&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package br.olx.crawler.util;&#10;&#10;import java.io.PrintStream;&#10;import java.io.UnsupportedEncodingException;&#10;import java.nio.charset.StandardCharsets;&#10;&#10;public class SystemOutUtil {&#10;    &#10;    public static void configureConsoleEncoding() {&#10;        try {&#10;            // Configurar a saída padrão para UTF-8&#10;            System.setOut(new PrintStream(System.out, true, StandardCharsets.UTF_8.name()));&#10;            System.setErr(new PrintStream(System.err, true, StandardCharsets.UTF_8.name()));&#10;            &#10;            // Configurar propriedades do sistema para UTF-8&#10;            System.setProperty(&quot;file.encoding&quot;, &quot;UTF-8&quot;);&#10;            System.setProperty(&quot;console.encoding&quot;, &quot;UTF-8&quot;);&#10;            &#10;        } catch (UnsupportedEncodingException e) {&#10;            System.err.println(&quot;Erro ao configurar codificação UTF-8: &quot; + e.getMessage());&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>